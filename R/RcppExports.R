# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

GPpred_rcpp <- function(K, Kstar, Kstarstar, y, only_mean = FALSE) {
    .Call('_GauProMod_GPpred_rcpp', PACKAGE = 'GauProMod', K, Kstar, Kstarstar, y, only_mean)
}

GPpredmean_rcpp <- function(K, Kstar, Kstarstar, y, H, Hstar, only_mean = FALSE) {
    .Call('_GauProMod_GPpredmean_rcpp', PACKAGE = 'GauProMod', K, Kstar, Kstarstar, y, H, Hstar, only_mean)
}

cholupdateL_rcpp <- function(L, V12, V22) {
    .Call('_GauProMod_cholupdateL_rcpp', PACKAGE = 'GauProMod', L, V12, V22)
}

cholfac_rcpp <- function(A) {
    .Call('_GauProMod_cholfac_rcpp', PACKAGE = 'GauProMod', A)
}

#' Cross-distance between two matrices (RcppEigen version)
#'
#' Compute the Mahalanobis or Euclidean distance between every row of two matrices.
#' Dispatches to optimized symmetric/unsymmetric core functions.
#' @param X a matrix (or vector, handled as a matrix)
#' @param Y a matrix (or vector) with the same number of columns as X
#' @param M a positive semi-definite matrix for Mahalanobis distance, or NULL for Euclidean.
#' @param use_symmetry If TRUE, assumes X=Y, skips redundant calculations, and forces the diagonal to zero.
#' @return A distance matrix of dimension nrow(X) x nrow(Y).
crossDist_rcpp <- function(X, Y, M = NULL, use_symmetry = FALSE) {
    .Call('_GauProMod_crossDist_rcpp', PACKAGE = 'GauProMod', X, Y, M, use_symmetry)
}

#' Fully Vectorized Sparse Cross-Distance (No Loops)
#'
#' Computes pairwise Euclidean or Mahalanobis distances between rows of X and Y,
#' returning only distances <= rmax as a sparse matrix. Entirely loop-free using Eigen.
#'
#' @param X Numeric matrix (n x p)
#' @param Y Numeric matrix (m x p)
#' @param rmax Maximum distance to store. Default is \code{Inf}.
#' @param M Optional positive semi-definite matrix for Mahalanobis distance
#' @return Sparse distance matrix (n x m) with distances <= rmax
crossDist_sparse <- function(X, Y, rmax, M = NULL) {
    .Call('_GauProMod_crossDist_sparse', PACKAGE = 'GauProMod', X, Y, rmax, M)
}

#' Kernel Dispatcher: Gaussian, Matern, Cauchy, Linear, Polynomial, Spherical
#'
#' Computes a kernel matrix for various kernels with optional derivatives.
#'
#' @param X Numeric matrix (n x p) or distance matrix (n x m) depending on kernel.
#' @param Y Numeric matrix (m x p) or distance matrix (n x m) depending on kernel.
#' @param l Length scale (used for Gaussian, Matern, Cauchy, etc.).
#' @param h Marginal standard deviation / scaling.
#' @param v Parameter for Matern (nu) or Cauchy (nu) kernels.
#' @param degree Degree of polynomial kernel (for polynomial kernel).
#' @param c Bias term (for linear/polynomial kernels).
#' @param d Derivative order: 0 = kernel, 1 = first derivative, 2 = second derivative.
#' @param W Weight matrix (n x m), used to scale derivatives.
#' @param kernel Kernel type: "gaussian", "matern", "cauchy", "linear", "polynomial", "spherical".
#' @param use_symmetry Logical, if TRUE enforces symmetry (only valid for square X/Y).
#' @return Kernel matrix (n x m) or derivatives as matrix.
NULL

#' Kernel Dispatcher (Dense + Sparse Support)
#'
#' Computes kernel matrices for a variety of kernels, supporting both dense feature matrices
#' and sparse distance matrices (dgCMatrix). Automatically dispatches to optimized implementations
#' depending on the kernel type and input format.
#'
#' Supported kernels:
#' * Distance-based kernels (sparse/dense): `"gaussian"`, `"matern"`, `"cauchy"`, `"triangular"`, `"spherical"`
#' * Feature/Gram kernels (dense only): `"linear"`, `"polynomial"`
#'
#' Derivatives are supported via the `d` argument:
#' * `d = 0`: Kernel values
#' * `d = 1`: First derivative
#' * `d = 2`: Second derivative
#'
#' Symmetry enforcement (`use_symmetry = TRUE`) works for square distance matrices only.
#'
#' @param X Dense numeric matrix or sparse dgCMatrix (distance matrix for distance kernels)
#' @param Y Dense numeric matrix or sparse dgCMatrix (same dimensions as X)
#' @param l Length scale (>0) for distance kernels
#' @param h Scale factor / marginal standard deviation
#' @param v Smoothness parameter (`nu`) for Matern or shape for Cauchy
#' @param degree Polynomial degree (integer >=1) for polynomial kernel
#' @param c Bias term for linear/polynomial kernels
#' @param d Derivative order: 0, 1, or 2
#' @param W Dense or sparse weight matrix, same dimensions as X/Y, scales derivatives elementwise
#' @param kernel Kernel type (string): `"gaussian"`, `"matern"`, `"cauchy"`, `"triangular"`, `"spherical"`, `"linear"`, `"polynomial"`
#' @param use_symmetry Logical; if TRUE, enforces symmetry (only valid for square X/Y distance matrices)
#' @return Kernel matrix (dense `MatrixXd` if inputs are dense, sparse `dgCMatrix` if inputs are sparse)
#' @examples
#' # Dense Gaussian kernel
#' X <- matrix(rnorm(20), 5, 4)
#' W <- matrix(1, nrow(X), nrow(X))
#' k <- kernel_dispatch_auto_rcpp(X, X, l=1, h=1, v=0, degree=0, c=0, d=0, W, "gaussian", TRUE)
#'
#' # Sparse distance-based Matern kernel
#' library(Matrix)
#' R <- as(Matrix(dist(matrix(rnorm(25),5,5))), "dgCMatrix")
#' Wsp <- Matrix(1,5,5,sparse=TRUE)
#' Ksp <- kernel_dispatch_auto_rcpp(R, R, l=1, h=1, v=1.5, degree=0, c=0, d=0, Wsp, "matern", TRUE)
kernel_dispatch_auto_rcpp <- function(X_s, Y_s, l, h, v, degree, c, d, W_s, kernel, use_symmetry = FALSE) {
    .Call('_GauProMod_kernel_dispatch_auto_rcpp', PACKAGE = 'GauProMod', X_s, Y_s, l, h, v, degree, c, d, W_s, kernel, use_symmetry)
}

